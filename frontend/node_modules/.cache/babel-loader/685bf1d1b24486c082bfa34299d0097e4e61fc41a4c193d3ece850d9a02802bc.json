{"ast":null,"code":"const API_BASE = process.env.REACT_APP_API_BASE || \"\";\nexport const getAccessToken = () => localStorage.getItem(\"accessToken\") || \"\";\nexport const setAccessToken = token => {\n  const value = String(token || \"\").trim();\n  if (value) {\n    localStorage.setItem(\"accessToken\", value);\n  } else {\n    localStorage.removeItem(\"accessToken\");\n  }\n};\nexport const apiFetch = async (path, options = {}) => {\n  const headers = new Headers(options.headers || {});\n  const token = getAccessToken();\n  if (token && !headers.has(\"Authorization\")) {\n    headers.set(\"Authorization\", `Bearer ${token}`);\n  }\n  const buildApiUrl = rawPath => {\n    if (rawPath.startsWith(\"http\")) return rawPath;\n    const normalizedBase = String(API_BASE || \"\").trim().replace(/\\/+$/, \"\");\n    let normalizedPath = rawPath.startsWith(\"/\") ? rawPath : `/${rawPath}`;\n\n    // Prevent \"/api/api/...\" when both base and path already include \"/api\".\n    const baseEndsWithApi = normalizedBase.endsWith(\"/api\");\n    if (baseEndsWithApi && normalizedPath.startsWith(\"/api/\")) {\n      normalizedPath = normalizedPath.slice(4);\n    }\n    return `${normalizedBase}${normalizedPath}`;\n  };\n  const url = buildApiUrl(path);\n  return fetch(url, {\n    ...options,\n    headers\n  });\n};\nexport const apiFetchJson = async (path, options = {}) => {\n  const response = await apiFetch(path, options);\n  const contentType = response.headers.get(\"content-type\") || \"\";\n  let data = {};\n  let text = \"\";\n  if (contentType.includes(\"application/json\")) {\n    data = await response.json().catch(() => ({}));\n  } else {\n    text = await response.text().catch(() => \"\");\n  }\n  if (!response.ok) {\n    var _data, _data2;\n    const textMessage = text ? text.replace(/<[^>]*>/g, \" \").replace(/\\s+/g, \" \").trim().slice(0, 240) : \"\";\n    const error = new Error(((_data = data) === null || _data === void 0 ? void 0 : _data.error) || ((_data2 = data) === null || _data2 === void 0 ? void 0 : _data2.message) || textMessage || `HTTP ${response.status}`);\n    error.status = response.status;\n    error.data = data;\n    if (text) {\n      error.raw = text;\n    }\n    throw error;\n  }\n  return contentType.includes(\"application/json\") ? data : {};\n};","map":{"version":3,"names":["API_BASE","process","env","REACT_APP_API_BASE","getAccessToken","localStorage","getItem","setAccessToken","token","value","String","trim","setItem","removeItem","apiFetch","path","options","headers","Headers","has","set","buildApiUrl","rawPath","startsWith","normalizedBase","replace","normalizedPath","baseEndsWithApi","endsWith","slice","url","fetch","apiFetchJson","response","contentType","get","data","text","includes","json","catch","ok","_data","_data2","textMessage","error","Error","message","status","raw"],"sources":["/Users/eurocare/Downloads/barvihaluxury-main/frontend/src/api.js"],"sourcesContent":["const API_BASE = process.env.REACT_APP_API_BASE || \"\";\n\nexport const getAccessToken = () => localStorage.getItem(\"accessToken\") || \"\";\n\nexport const setAccessToken = (token) => {\n  const value = String(token || \"\").trim();\n  if (value) {\n    localStorage.setItem(\"accessToken\", value);\n  } else {\n    localStorage.removeItem(\"accessToken\");\n  }\n};\n\nexport const apiFetch = async (path, options = {}) => {\n  const headers = new Headers(options.headers || {});\n  const token = getAccessToken();\n  if (token && !headers.has(\"Authorization\")) {\n    headers.set(\"Authorization\", `Bearer ${token}`);\n  }\n\n  const buildApiUrl = (rawPath) => {\n    if (rawPath.startsWith(\"http\")) return rawPath;\n\n    const normalizedBase = String(API_BASE || \"\").trim().replace(/\\/+$/, \"\");\n    let normalizedPath = rawPath.startsWith(\"/\") ? rawPath : `/${rawPath}`;\n\n    // Prevent \"/api/api/...\" when both base and path already include \"/api\".\n    const baseEndsWithApi = normalizedBase.endsWith(\"/api\");\n    if (baseEndsWithApi && normalizedPath.startsWith(\"/api/\")) {\n      normalizedPath = normalizedPath.slice(4);\n    }\n\n    return `${normalizedBase}${normalizedPath}`;\n  };\n\n  const url = buildApiUrl(path);\n  return fetch(url, { ...options, headers });\n};\n\nexport const apiFetchJson = async (path, options = {}) => {\n  const response = await apiFetch(path, options);\n  const contentType = response.headers.get(\"content-type\") || \"\";\n  let data = {};\n  let text = \"\";\n\n  if (contentType.includes(\"application/json\")) {\n    data = await response.json().catch(() => ({}));\n  } else {\n    text = await response.text().catch(() => \"\");\n  }\n\n  if (!response.ok) {\n    const textMessage = text\n      ? text.replace(/<[^>]*>/g, \" \").replace(/\\s+/g, \" \").trim().slice(0, 240)\n      : \"\";\n    const error = new Error(data?.error || data?.message || textMessage || `HTTP ${response.status}`);\n    error.status = response.status;\n    error.data = data;\n    if (text) {\n      error.raw = text;\n    }\n    throw error;\n  }\n  return contentType.includes(\"application/json\") ? data : {};\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}