{"ast":null,"code":"const resolveApiBase = () => {\n  const envBase = process.env.REACT_APP_API_BASE || \"\";\n  if (envBase) return envBase;\n  if (typeof window === \"undefined\") return \"\";\n  const {\n    hostname,\n    port,\n    protocol\n  } = window.location || {};\n  const isLocalhost = hostname === \"localhost\" || hostname === \"127.0.0.1\";\n  if (isLocalhost && String(port || \"\") === \"3000\") {\n    return `${protocol}//${hostname}:5000`;\n  }\n  return \"\";\n};\nconst API_BASE = resolveApiBase();\nconst sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\nconst isRetryableNetworkError = error => {\n  if (!error) return false;\n  if (error.name === \"AbortError\") return true;\n  const msg = String(error.message || \"\").toLowerCase();\n  return msg.includes(\"failed to fetch\") || msg.includes(\"networkerror\") || msg.includes(\"network error\") || msg.includes(\"load failed\") || msg.includes(\"connection reset\") || msg.includes(\"timeout\") || msg.includes(\"timed out\");\n};\nexport const getAccessToken = () => localStorage.getItem(\"accessToken\") || \"\";\nexport const setAccessToken = token => {\n  const value = String(token || \"\").trim();\n  if (value) {\n    localStorage.setItem(\"accessToken\", value);\n  } else {\n    localStorage.removeItem(\"accessToken\");\n  }\n};\nexport const apiFetch = async (path, options = {}) => {\n  const {\n    timeoutMs = 45000,\n    retry,\n    _retried = false,\n    ...fetchOptions\n  } = options || {};\n  const method = String(fetchOptions.method || \"GET\").toUpperCase();\n  const allowRetry = typeof retry === \"boolean\" ? retry : method === \"GET\" || method === \"HEAD\";\n  const timeoutValue = Number(timeoutMs);\n  const shouldTimeout = Number.isFinite(timeoutValue) && timeoutValue > 0;\n  const headers = new Headers(fetchOptions.headers || {});\n  const token = getAccessToken();\n  if (token && !headers.has(\"Authorization\")) {\n    headers.set(\"Authorization\", `Bearer ${token}`);\n  }\n  const buildApiUrl = rawPath => {\n    if (rawPath.startsWith(\"http\")) return rawPath;\n    const normalizedBase = String(API_BASE || \"\").trim().replace(/\\/+$/, \"\");\n    let normalizedPath = rawPath.startsWith(\"/\") ? rawPath : `/${rawPath}`;\n\n    // Prevent \"/api/api/...\" when both base and path already include \"/api\".\n    const baseEndsWithApi = normalizedBase.endsWith(\"/api\");\n    if (baseEndsWithApi && normalizedPath.startsWith(\"/api/\")) {\n      normalizedPath = normalizedPath.slice(4);\n    }\n    return `${normalizedBase}${normalizedPath}`;\n  };\n  const url = buildApiUrl(path);\n  const controller = !fetchOptions.signal && shouldTimeout ? new AbortController() : null;\n  const timerId = controller ? setTimeout(() => controller.abort(), Math.max(5000, timeoutValue)) : null;\n  try {\n    return await fetch(url, {\n      ...fetchOptions,\n      headers,\n      cache: fetchOptions.cache || \"no-store\",\n      signal: fetchOptions.signal || (controller === null || controller === void 0 ? void 0 : controller.signal)\n    });\n  } catch (error) {\n    if (!_retried && allowRetry && isRetryableNetworkError(error)) {\n      await sleep(350);\n      return apiFetch(path, {\n        ...options,\n        _retried: true\n      });\n    }\n    throw error;\n  } finally {\n    if (timerId) clearTimeout(timerId);\n  }\n};\nexport const apiFetchJson = async (path, options = {}) => {\n  const response = await apiFetch(path, options);\n  const contentType = response.headers.get(\"content-type\") || \"\";\n  let data = {};\n  let text = \"\";\n  if (contentType.includes(\"application/json\")) {\n    data = await response.json().catch(() => ({}));\n  } else {\n    text = await response.text().catch(() => \"\");\n  }\n  if (!response.ok) {\n    var _data, _data2;\n    const textMessage = text ? text.replace(/<[^>]*>/g, \" \").replace(/\\s+/g, \" \").trim().slice(0, 240) : \"\";\n    const error = new Error(((_data = data) === null || _data === void 0 ? void 0 : _data.error) || ((_data2 = data) === null || _data2 === void 0 ? void 0 : _data2.message) || textMessage || `HTTP ${response.status}`);\n    error.status = response.status;\n    error.data = data;\n    if (text) {\n      error.raw = text;\n    }\n    throw error;\n  }\n  return contentType.includes(\"application/json\") ? data : {};\n};","map":{"version":3,"names":["resolveApiBase","envBase","process","env","REACT_APP_API_BASE","window","hostname","port","protocol","location","isLocalhost","String","API_BASE","sleep","ms","Promise","resolve","setTimeout","isRetryableNetworkError","error","name","msg","message","toLowerCase","includes","getAccessToken","localStorage","getItem","setAccessToken","token","value","trim","setItem","removeItem","apiFetch","path","options","timeoutMs","retry","_retried","fetchOptions","method","toUpperCase","allowRetry","timeoutValue","Number","shouldTimeout","isFinite","headers","Headers","has","set","buildApiUrl","rawPath","startsWith","normalizedBase","replace","normalizedPath","baseEndsWithApi","endsWith","slice","url","controller","signal","AbortController","timerId","abort","Math","max","fetch","cache","clearTimeout","apiFetchJson","response","contentType","get","data","text","json","catch","ok","_data","_data2","textMessage","Error","status","raw"],"sources":["/Users/eurocare/Downloads/barvihaluxury-main/frontend/src/api.js"],"sourcesContent":["const resolveApiBase = () => {\n  const envBase = process.env.REACT_APP_API_BASE || \"\";\n  if (envBase) return envBase;\n  if (typeof window === \"undefined\") return \"\";\n  const { hostname, port, protocol } = window.location || {};\n  const isLocalhost = hostname === \"localhost\" || hostname === \"127.0.0.1\";\n  if (isLocalhost && String(port || \"\") === \"3000\") {\n    return `${protocol}//${hostname}:5000`;\n  }\n  return \"\";\n};\n\nconst API_BASE = resolveApiBase();\n\nconst sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\nconst isRetryableNetworkError = (error) => {\n  if (!error) return false;\n  if (error.name === \"AbortError\") return true;\n  const msg = String(error.message || \"\").toLowerCase();\n  return (\n    msg.includes(\"failed to fetch\") ||\n    msg.includes(\"networkerror\") ||\n    msg.includes(\"network error\") ||\n    msg.includes(\"load failed\") ||\n    msg.includes(\"connection reset\") ||\n    msg.includes(\"timeout\") ||\n    msg.includes(\"timed out\")\n  );\n};\n\nexport const getAccessToken = () => localStorage.getItem(\"accessToken\") || \"\";\n\nexport const setAccessToken = (token) => {\n  const value = String(token || \"\").trim();\n  if (value) {\n    localStorage.setItem(\"accessToken\", value);\n  } else {\n    localStorage.removeItem(\"accessToken\");\n  }\n};\n\nexport const apiFetch = async (path, options = {}) => {\n  const {\n    timeoutMs = 45000,\n    retry,\n    _retried = false,\n    ...fetchOptions\n  } = options || {};\n\n  const method = String(fetchOptions.method || \"GET\").toUpperCase();\n  const allowRetry = typeof retry === \"boolean\" ? retry : (method === \"GET\" || method === \"HEAD\");\n  const timeoutValue = Number(timeoutMs);\n  const shouldTimeout = Number.isFinite(timeoutValue) && timeoutValue > 0;\n\n  const headers = new Headers(fetchOptions.headers || {});\n  const token = getAccessToken();\n  if (token && !headers.has(\"Authorization\")) {\n    headers.set(\"Authorization\", `Bearer ${token}`);\n  }\n\n  const buildApiUrl = (rawPath) => {\n    if (rawPath.startsWith(\"http\")) return rawPath;\n\n    const normalizedBase = String(API_BASE || \"\").trim().replace(/\\/+$/, \"\");\n    let normalizedPath = rawPath.startsWith(\"/\") ? rawPath : `/${rawPath}`;\n\n    // Prevent \"/api/api/...\" when both base and path already include \"/api\".\n    const baseEndsWithApi = normalizedBase.endsWith(\"/api\");\n    if (baseEndsWithApi && normalizedPath.startsWith(\"/api/\")) {\n      normalizedPath = normalizedPath.slice(4);\n    }\n\n    return `${normalizedBase}${normalizedPath}`;\n  };\n\n  const url = buildApiUrl(path);\n  const controller = !fetchOptions.signal && shouldTimeout ? new AbortController() : null;\n  const timerId = controller\n    ? setTimeout(() => controller.abort(), Math.max(5000, timeoutValue))\n    : null;\n\n  try {\n    return await fetch(url, {\n      ...fetchOptions,\n      headers,\n      cache: fetchOptions.cache || \"no-store\",\n      signal: fetchOptions.signal || controller?.signal\n    });\n  } catch (error) {\n    if (!_retried && allowRetry && isRetryableNetworkError(error)) {\n      await sleep(350);\n      return apiFetch(path, { ...options, _retried: true });\n    }\n    throw error;\n  } finally {\n    if (timerId) clearTimeout(timerId);\n  }\n};\n\nexport const apiFetchJson = async (path, options = {}) => {\n  const response = await apiFetch(path, options);\n  const contentType = response.headers.get(\"content-type\") || \"\";\n  let data = {};\n  let text = \"\";\n\n  if (contentType.includes(\"application/json\")) {\n    data = await response.json().catch(() => ({}));\n  } else {\n    text = await response.text().catch(() => \"\");\n  }\n\n  if (!response.ok) {\n    const textMessage = text\n      ? text.replace(/<[^>]*>/g, \" \").replace(/\\s+/g, \" \").trim().slice(0, 240)\n      : \"\";\n    const error = new Error(data?.error || data?.message || textMessage || `HTTP ${response.status}`);\n    error.status = response.status;\n    error.data = data;\n    if (text) {\n      error.raw = text;\n    }\n    throw error;\n  }\n  return contentType.includes(\"application/json\") ? data : {};\n};\n"],"mappings":"AAAA,MAAMA,cAAc,GAAGA,CAAA,KAAM;EAC3B,MAAMC,OAAO,GAAGC,OAAO,CAACC,GAAG,CAACC,kBAAkB,IAAI,EAAE;EACpD,IAAIH,OAAO,EAAE,OAAOA,OAAO;EAC3B,IAAI,OAAOI,MAAM,KAAK,WAAW,EAAE,OAAO,EAAE;EAC5C,MAAM;IAAEC,QAAQ;IAAEC,IAAI;IAAEC;EAAS,CAAC,GAAGH,MAAM,CAACI,QAAQ,IAAI,CAAC,CAAC;EAC1D,MAAMC,WAAW,GAAGJ,QAAQ,KAAK,WAAW,IAAIA,QAAQ,KAAK,WAAW;EACxE,IAAII,WAAW,IAAIC,MAAM,CAACJ,IAAI,IAAI,EAAE,CAAC,KAAK,MAAM,EAAE;IAChD,OAAO,GAAGC,QAAQ,KAAKF,QAAQ,OAAO;EACxC;EACA,OAAO,EAAE;AACX,CAAC;AAED,MAAMM,QAAQ,GAAGZ,cAAc,CAAC,CAAC;AAEjC,MAAMa,KAAK,GAAIC,EAAE,IAAK,IAAIC,OAAO,CAAEC,OAAO,IAAKC,UAAU,CAACD,OAAO,EAAEF,EAAE,CAAC,CAAC;AAEvE,MAAMI,uBAAuB,GAAIC,KAAK,IAAK;EACzC,IAAI,CAACA,KAAK,EAAE,OAAO,KAAK;EACxB,IAAIA,KAAK,CAACC,IAAI,KAAK,YAAY,EAAE,OAAO,IAAI;EAC5C,MAAMC,GAAG,GAAGV,MAAM,CAACQ,KAAK,CAACG,OAAO,IAAI,EAAE,CAAC,CAACC,WAAW,CAAC,CAAC;EACrD,OACEF,GAAG,CAACG,QAAQ,CAAC,iBAAiB,CAAC,IAC/BH,GAAG,CAACG,QAAQ,CAAC,cAAc,CAAC,IAC5BH,GAAG,CAACG,QAAQ,CAAC,eAAe,CAAC,IAC7BH,GAAG,CAACG,QAAQ,CAAC,aAAa,CAAC,IAC3BH,GAAG,CAACG,QAAQ,CAAC,kBAAkB,CAAC,IAChCH,GAAG,CAACG,QAAQ,CAAC,SAAS,CAAC,IACvBH,GAAG,CAACG,QAAQ,CAAC,WAAW,CAAC;AAE7B,CAAC;AAED,OAAO,MAAMC,cAAc,GAAGA,CAAA,KAAMC,YAAY,CAACC,OAAO,CAAC,aAAa,CAAC,IAAI,EAAE;AAE7E,OAAO,MAAMC,cAAc,GAAIC,KAAK,IAAK;EACvC,MAAMC,KAAK,GAAGnB,MAAM,CAACkB,KAAK,IAAI,EAAE,CAAC,CAACE,IAAI,CAAC,CAAC;EACxC,IAAID,KAAK,EAAE;IACTJ,YAAY,CAACM,OAAO,CAAC,aAAa,EAAEF,KAAK,CAAC;EAC5C,CAAC,MAAM;IACLJ,YAAY,CAACO,UAAU,CAAC,aAAa,CAAC;EACxC;AACF,CAAC;AAED,OAAO,MAAMC,QAAQ,GAAG,MAAAA,CAAOC,IAAI,EAAEC,OAAO,GAAG,CAAC,CAAC,KAAK;EACpD,MAAM;IACJC,SAAS,GAAG,KAAK;IACjBC,KAAK;IACLC,QAAQ,GAAG,KAAK;IAChB,GAAGC;EACL,CAAC,GAAGJ,OAAO,IAAI,CAAC,CAAC;EAEjB,MAAMK,MAAM,GAAG9B,MAAM,CAAC6B,YAAY,CAACC,MAAM,IAAI,KAAK,CAAC,CAACC,WAAW,CAAC,CAAC;EACjE,MAAMC,UAAU,GAAG,OAAOL,KAAK,KAAK,SAAS,GAAGA,KAAK,GAAIG,MAAM,KAAK,KAAK,IAAIA,MAAM,KAAK,MAAO;EAC/F,MAAMG,YAAY,GAAGC,MAAM,CAACR,SAAS,CAAC;EACtC,MAAMS,aAAa,GAAGD,MAAM,CAACE,QAAQ,CAACH,YAAY,CAAC,IAAIA,YAAY,GAAG,CAAC;EAEvE,MAAMI,OAAO,GAAG,IAAIC,OAAO,CAACT,YAAY,CAACQ,OAAO,IAAI,CAAC,CAAC,CAAC;EACvD,MAAMnB,KAAK,GAAGJ,cAAc,CAAC,CAAC;EAC9B,IAAII,KAAK,IAAI,CAACmB,OAAO,CAACE,GAAG,CAAC,eAAe,CAAC,EAAE;IAC1CF,OAAO,CAACG,GAAG,CAAC,eAAe,EAAE,UAAUtB,KAAK,EAAE,CAAC;EACjD;EAEA,MAAMuB,WAAW,GAAIC,OAAO,IAAK;IAC/B,IAAIA,OAAO,CAACC,UAAU,CAAC,MAAM,CAAC,EAAE,OAAOD,OAAO;IAE9C,MAAME,cAAc,GAAG5C,MAAM,CAACC,QAAQ,IAAI,EAAE,CAAC,CAACmB,IAAI,CAAC,CAAC,CAACyB,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC;IACxE,IAAIC,cAAc,GAAGJ,OAAO,CAACC,UAAU,CAAC,GAAG,CAAC,GAAGD,OAAO,GAAG,IAAIA,OAAO,EAAE;;IAEtE;IACA,MAAMK,eAAe,GAAGH,cAAc,CAACI,QAAQ,CAAC,MAAM,CAAC;IACvD,IAAID,eAAe,IAAID,cAAc,CAACH,UAAU,CAAC,OAAO,CAAC,EAAE;MACzDG,cAAc,GAAGA,cAAc,CAACG,KAAK,CAAC,CAAC,CAAC;IAC1C;IAEA,OAAO,GAAGL,cAAc,GAAGE,cAAc,EAAE;EAC7C,CAAC;EAED,MAAMI,GAAG,GAAGT,WAAW,CAACjB,IAAI,CAAC;EAC7B,MAAM2B,UAAU,GAAG,CAACtB,YAAY,CAACuB,MAAM,IAAIjB,aAAa,GAAG,IAAIkB,eAAe,CAAC,CAAC,GAAG,IAAI;EACvF,MAAMC,OAAO,GAAGH,UAAU,GACtB7C,UAAU,CAAC,MAAM6C,UAAU,CAACI,KAAK,CAAC,CAAC,EAAEC,IAAI,CAACC,GAAG,CAAC,IAAI,EAAExB,YAAY,CAAC,CAAC,GAClE,IAAI;EAER,IAAI;IACF,OAAO,MAAMyB,KAAK,CAACR,GAAG,EAAE;MACtB,GAAGrB,YAAY;MACfQ,OAAO;MACPsB,KAAK,EAAE9B,YAAY,CAAC8B,KAAK,IAAI,UAAU;MACvCP,MAAM,EAAEvB,YAAY,CAACuB,MAAM,KAAID,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEC,MAAM;IACnD,CAAC,CAAC;EACJ,CAAC,CAAC,OAAO5C,KAAK,EAAE;IACd,IAAI,CAACoB,QAAQ,IAAII,UAAU,IAAIzB,uBAAuB,CAACC,KAAK,CAAC,EAAE;MAC7D,MAAMN,KAAK,CAAC,GAAG,CAAC;MAChB,OAAOqB,QAAQ,CAACC,IAAI,EAAE;QAAE,GAAGC,OAAO;QAAEG,QAAQ,EAAE;MAAK,CAAC,CAAC;IACvD;IACA,MAAMpB,KAAK;EACb,CAAC,SAAS;IACR,IAAI8C,OAAO,EAAEM,YAAY,CAACN,OAAO,CAAC;EACpC;AACF,CAAC;AAED,OAAO,MAAMO,YAAY,GAAG,MAAAA,CAAOrC,IAAI,EAAEC,OAAO,GAAG,CAAC,CAAC,KAAK;EACxD,MAAMqC,QAAQ,GAAG,MAAMvC,QAAQ,CAACC,IAAI,EAAEC,OAAO,CAAC;EAC9C,MAAMsC,WAAW,GAAGD,QAAQ,CAACzB,OAAO,CAAC2B,GAAG,CAAC,cAAc,CAAC,IAAI,EAAE;EAC9D,IAAIC,IAAI,GAAG,CAAC,CAAC;EACb,IAAIC,IAAI,GAAG,EAAE;EAEb,IAAIH,WAAW,CAAClD,QAAQ,CAAC,kBAAkB,CAAC,EAAE;IAC5CoD,IAAI,GAAG,MAAMH,QAAQ,CAACK,IAAI,CAAC,CAAC,CAACC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;EAChD,CAAC,MAAM;IACLF,IAAI,GAAG,MAAMJ,QAAQ,CAACI,IAAI,CAAC,CAAC,CAACE,KAAK,CAAC,MAAM,EAAE,CAAC;EAC9C;EAEA,IAAI,CAACN,QAAQ,CAACO,EAAE,EAAE;IAAA,IAAAC,KAAA,EAAAC,MAAA;IAChB,MAAMC,WAAW,GAAGN,IAAI,GACpBA,IAAI,CAACrB,OAAO,CAAC,UAAU,EAAE,GAAG,CAAC,CAACA,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,CAACzB,IAAI,CAAC,CAAC,CAAC6B,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,GACvE,EAAE;IACN,MAAMzC,KAAK,GAAG,IAAIiE,KAAK,CAAC,EAAAH,KAAA,GAAAL,IAAI,cAAAK,KAAA,uBAAJA,KAAA,CAAM9D,KAAK,OAAA+D,MAAA,GAAIN,IAAI,cAAAM,MAAA,uBAAJA,MAAA,CAAM5D,OAAO,KAAI6D,WAAW,IAAI,QAAQV,QAAQ,CAACY,MAAM,EAAE,CAAC;IACjGlE,KAAK,CAACkE,MAAM,GAAGZ,QAAQ,CAACY,MAAM;IAC9BlE,KAAK,CAACyD,IAAI,GAAGA,IAAI;IACjB,IAAIC,IAAI,EAAE;MACR1D,KAAK,CAACmE,GAAG,GAAGT,IAAI;IAClB;IACA,MAAM1D,KAAK;EACb;EACA,OAAOuD,WAAW,CAAClD,QAAQ,CAAC,kBAAkB,CAAC,GAAGoD,IAAI,GAAG,CAAC,CAAC;AAC7D,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}