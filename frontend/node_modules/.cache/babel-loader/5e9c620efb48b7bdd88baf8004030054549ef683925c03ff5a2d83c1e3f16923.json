{"ast":null,"code":"const normalizeBase = value => String(value || \"\").trim().replace(/\\/+$/, \"\");\nconst getRuntimeOrigin = () => {\n  if (typeof window === \"undefined\" || !window.location) return \"\";\n  return normalizeBase(window.location.origin || \"\");\n};\n\n// Keep defaults safe for production: prefer same-origin (relative \"/api/...\") to avoid CORS/mixed-content.\n// Allow the hardcoded IP fallback on plain HTTP deployments as a fallback when reverse proxy is misconfigured.\nconst resolveDefaultApiBases = () => {\n  const origin = getRuntimeOrigin();\n  const isLocal = origin.includes(\"localhost\") || origin.includes(\"127.0.0.1\");\n  const protocol = typeof window !== \"undefined\" && window.location ? window.location.protocol : \"\";\n  const canUseHttpFallback = protocol !== \"https:\";\n  const bases = [\"\"];\n  if (isLocal || canUseHttpFallback) {\n    bases.push(\"http://95.81.100.250\");\n  }\n  return bases;\n};\nconst resolveApiBases = () => {\n  const envBase = String(process.env.REACT_APP_API_BASE || \"\").trim();\n  if (envBase) {\n    return envBase.split(\",\").map(item => normalizeBase(item)).filter(Boolean);\n  }\n  return resolveDefaultApiBases().map(item => normalizeBase(item)).filter((item, index, arr) => arr.indexOf(item) === index);\n};\nconst API_BASES = resolveApiBases();\nconst getCandidateKey = base => {\n  const normalized = normalizeBase(base);\n  if (normalized) return normalized;\n  return getRuntimeOrigin() || \"__relative__\";\n};\nconst sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\nconst makeRequestId = () => `req-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;\nconst isRetryableNetworkError = error => {\n  if (!error) return false;\n  if (error.name === \"AbortError\") return true;\n  const msg = String(error.message || \"\").toLowerCase();\n  return msg.includes(\"failed to fetch\") || msg.includes(\"networkerror\") || msg.includes(\"network error\") || msg.includes(\"load failed\") || msg.includes(\"connection reset\") || msg.includes(\"timeout\") || msg.includes(\"timed out\");\n};\nexport const getAccessToken = () => localStorage.getItem(\"accessToken\") || \"\";\nexport const setAccessToken = token => {\n  const value = String(token || \"\").trim();\n  if (value) {\n    localStorage.setItem(\"accessToken\", value);\n  } else {\n    localStorage.removeItem(\"accessToken\");\n  }\n};\nexport const apiFetch = async (path, options = {}) => {\n  const {\n    timeoutMs = 45000,\n    retry,\n    allowBaseFallback,\n    skipAuth,\n    skipClientRequestId,\n    _retried = false,\n    ...fetchOptions\n  } = options || {};\n  const method = String(fetchOptions.method || \"GET\").toUpperCase();\n  const allowRetry = typeof retry === \"boolean\" ? retry : method === \"GET\" || method === \"HEAD\";\n  const shouldFallbackBetweenBases = typeof allowBaseFallback === \"boolean\" ? allowBaseFallback : allowRetry;\n  const timeoutValue = Number(timeoutMs);\n  const shouldTimeout = Number.isFinite(timeoutValue) && timeoutValue > 0;\n  const requestId = String(fetchOptions.requestId || makeRequestId());\n  const headers = new Headers(fetchOptions.headers || {});\n  const token = getAccessToken();\n  if (!skipAuth && token && !headers.has(\"Authorization\")) {\n    headers.set(\"Authorization\", `Bearer ${token}`);\n  }\n  if (!skipClientRequestId && !headers.has(\"X-Client-Request-Id\")) {\n    headers.set(\"X-Client-Request-Id\", requestId);\n  }\n  const buildApiUrl = (rawPath, base) => {\n    if (rawPath.startsWith(\"http\")) return rawPath;\n    const normalizedBase = normalizeBase(base);\n    let normalizedPath = rawPath.startsWith(\"/\") ? rawPath : `/${rawPath}`;\n\n    // Prevent \"/api/api/...\" when both base and path already include \"/api\".\n    const baseEndsWithApi = normalizedBase.endsWith(\"/api\");\n    if (baseEndsWithApi && normalizedPath.startsWith(\"/api/\")) {\n      normalizedPath = normalizedPath.slice(4);\n    }\n    return `${normalizedBase}${normalizedPath}`;\n  };\n  const toError = error => {\n    if (error instanceof Error) return error;\n    return new Error(String(error || \"Failed to fetch\"));\n  };\n  const candidates = path.startsWith(\"http\") ? [\"\"] : API_BASES;\n  const seenCandidateKeys = new Set();\n  const uniqueCandidates = candidates.filter(item => {\n    const key = getCandidateKey(item);\n    if (seenCandidateKeys.has(key)) return false;\n    seenCandidateKeys.add(key);\n    return true;\n  });\n  const activeCandidates = shouldFallbackBetweenBases ? uniqueCandidates : uniqueCandidates.slice(0, 1);\n  let lastError = null;\n  for (let index = 0; index < activeCandidates.length; index += 1) {\n    const base = activeCandidates[index];\n    const url = buildApiUrl(path, base);\n    let timedOut = false;\n    const controller = !fetchOptions.signal && shouldTimeout ? new AbortController() : null;\n    const timerId = controller ? setTimeout(() => {\n      timedOut = true;\n      controller.abort();\n    }, Math.max(5000, timeoutValue)) : null;\n    try {\n      const response = await fetch(url, {\n        ...fetchOptions,\n        headers,\n        cache: fetchOptions.cache || \"no-store\",\n        signal: fetchOptions.signal || (controller === null || controller === void 0 ? void 0 : controller.signal)\n      });\n      return response;\n    } catch (error) {\n      if (timedOut) {\n        const timeoutError = new Error(`Request timeout after ${Math.max(5000, timeoutValue)}ms (${method} ${path})`);\n        timeoutError.name = \"AbortError\";\n        timeoutError.code = \"REQUEST_TIMEOUT\";\n        timeoutError.method = method;\n        timeoutError.path = path;\n        timeoutError.url = url;\n        timeoutError.timeoutMs = Math.max(5000, timeoutValue);\n        timeoutError.originalError = error;\n        timeoutError.requestId = requestId;\n        lastError = timeoutError;\n      } else {\n        const networkError = toError(error);\n        // Keep the error message concise but actionable in the UI.\n        if (!networkError.message || networkError.message.toLowerCase() === \"failed to fetch\") {\n          networkError.message = `${networkError.message || \"Failed to fetch\"} (${method} ${path})`;\n        }\n        networkError.code = networkError.code || \"FETCH_FAILED\";\n        networkError.method = method;\n        networkError.path = path;\n        networkError.url = url;\n        networkError.requestId = requestId;\n        networkError.originalError = error;\n        lastError = networkError;\n      }\n      const hasAnotherBase = shouldFallbackBetweenBases && index < activeCandidates.length - 1;\n      if (!hasAnotherBase) break;\n      if (!isRetryableNetworkError(lastError)) break;\n    } finally {\n      if (timerId) clearTimeout(timerId);\n    }\n  }\n  if (!_retried && allowRetry && isRetryableNetworkError(lastError)) {\n    await sleep(350);\n    return apiFetch(path, {\n      ...options,\n      _retried: true\n    });\n  }\n  if (lastError) throw lastError;\n  const genericError = new Error(\"Failed to fetch\");\n  genericError.requestId = requestId;\n  throw genericError;\n};\nexport const apiFetchJson = async (path, options = {}) => {\n  const response = await apiFetch(path, options);\n  const contentType = response.headers.get(\"content-type\") || \"\";\n  let data = {};\n  let text = \"\";\n  if (contentType.includes(\"application/json\")) {\n    data = await response.json().catch(() => ({}));\n  } else {\n    text = await response.text().catch(() => \"\");\n  }\n  if (!response.ok) {\n    var _data, _data2;\n    const textMessage = text ? text.replace(/<[^>]*>/g, \" \").replace(/\\s+/g, \" \").trim().slice(0, 240) : \"\";\n    const error = new Error(((_data = data) === null || _data === void 0 ? void 0 : _data.error) || ((_data2 = data) === null || _data2 === void 0 ? void 0 : _data2.message) || textMessage || `HTTP ${response.status}`);\n    error.status = response.status;\n    error.data = data;\n    if (text) {\n      error.raw = text;\n    }\n    throw error;\n  }\n  return contentType.includes(\"application/json\") ? data : {};\n};","map":{"version":3,"names":["normalizeBase","value","String","trim","replace","getRuntimeOrigin","window","location","origin","resolveDefaultApiBases","isLocal","includes","protocol","canUseHttpFallback","bases","push","resolveApiBases","envBase","process","env","REACT_APP_API_BASE","split","map","item","filter","Boolean","index","arr","indexOf","API_BASES","getCandidateKey","base","normalized","sleep","ms","Promise","resolve","setTimeout","makeRequestId","Date","now","toString","Math","random","slice","isRetryableNetworkError","error","name","msg","message","toLowerCase","getAccessToken","localStorage","getItem","setAccessToken","token","setItem","removeItem","apiFetch","path","options","timeoutMs","retry","allowBaseFallback","skipAuth","skipClientRequestId","_retried","fetchOptions","method","toUpperCase","allowRetry","shouldFallbackBetweenBases","timeoutValue","Number","shouldTimeout","isFinite","requestId","headers","Headers","has","set","buildApiUrl","rawPath","startsWith","normalizedBase","normalizedPath","baseEndsWithApi","endsWith","toError","Error","candidates","seenCandidateKeys","Set","uniqueCandidates","key","add","activeCandidates","lastError","length","url","timedOut","controller","signal","AbortController","timerId","abort","max","response","fetch","cache","timeoutError","code","originalError","networkError","hasAnotherBase","clearTimeout","genericError","apiFetchJson","contentType","get","data","text","json","catch","ok","_data","_data2","textMessage","status","raw"],"sources":["/Users/eurocare/Downloads/barvihaluxury-main/frontend/src/api.js"],"sourcesContent":["const normalizeBase = (value) => String(value || \"\").trim().replace(/\\/+$/, \"\");\n\nconst getRuntimeOrigin = () => {\n  if (typeof window === \"undefined\" || !window.location) return \"\";\n  return normalizeBase(window.location.origin || \"\");\n};\n\n// Keep defaults safe for production: prefer same-origin (relative \"/api/...\") to avoid CORS/mixed-content.\n// Allow the hardcoded IP fallback on plain HTTP deployments as a fallback when reverse proxy is misconfigured.\nconst resolveDefaultApiBases = () => {\n  const origin = getRuntimeOrigin();\n  const isLocal = origin.includes(\"localhost\") || origin.includes(\"127.0.0.1\");\n  const protocol = typeof window !== \"undefined\" && window.location ? window.location.protocol : \"\";\n  const canUseHttpFallback = protocol !== \"https:\";\n\n  const bases = [\"\"];\n  if (isLocal || canUseHttpFallback) {\n    bases.push(\"http://95.81.100.250\");\n  }\n  return bases;\n};\n\nconst resolveApiBases = () => {\n  const envBase = String(process.env.REACT_APP_API_BASE || \"\").trim();\n  if (envBase) {\n    return envBase\n      .split(\",\")\n      .map((item) => normalizeBase(item))\n      .filter(Boolean);\n  }\n  return resolveDefaultApiBases()\n    .map((item) => normalizeBase(item))\n    .filter((item, index, arr) => arr.indexOf(item) === index);\n};\n\nconst API_BASES = resolveApiBases();\n\nconst getCandidateKey = (base) => {\n  const normalized = normalizeBase(base);\n  if (normalized) return normalized;\n  return getRuntimeOrigin() || \"__relative__\";\n};\n\nconst sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\nconst makeRequestId = () => `req-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;\n\nconst isRetryableNetworkError = (error) => {\n  if (!error) return false;\n  if (error.name === \"AbortError\") return true;\n  const msg = String(error.message || \"\").toLowerCase();\n  return (\n    msg.includes(\"failed to fetch\") ||\n    msg.includes(\"networkerror\") ||\n    msg.includes(\"network error\") ||\n    msg.includes(\"load failed\") ||\n    msg.includes(\"connection reset\") ||\n    msg.includes(\"timeout\") ||\n    msg.includes(\"timed out\")\n  );\n};\n\nexport const getAccessToken = () => localStorage.getItem(\"accessToken\") || \"\";\n\nexport const setAccessToken = (token) => {\n  const value = String(token || \"\").trim();\n  if (value) {\n    localStorage.setItem(\"accessToken\", value);\n  } else {\n    localStorage.removeItem(\"accessToken\");\n  }\n};\n\nexport const apiFetch = async (path, options = {}) => {\n  const {\n    timeoutMs = 45000,\n    retry,\n    allowBaseFallback,\n    skipAuth,\n    skipClientRequestId,\n    _retried = false,\n    ...fetchOptions\n  } = options || {};\n\n  const method = String(fetchOptions.method || \"GET\").toUpperCase();\n  const allowRetry = typeof retry === \"boolean\" ? retry : (method === \"GET\" || method === \"HEAD\");\n  const shouldFallbackBetweenBases = typeof allowBaseFallback === \"boolean\" ? allowBaseFallback : allowRetry;\n  const timeoutValue = Number(timeoutMs);\n  const shouldTimeout = Number.isFinite(timeoutValue) && timeoutValue > 0;\n  const requestId = String(fetchOptions.requestId || makeRequestId());\n\n  const headers = new Headers(fetchOptions.headers || {});\n  const token = getAccessToken();\n  if (!skipAuth && token && !headers.has(\"Authorization\")) {\n    headers.set(\"Authorization\", `Bearer ${token}`);\n  }\n  if (!skipClientRequestId && !headers.has(\"X-Client-Request-Id\")) {\n    headers.set(\"X-Client-Request-Id\", requestId);\n  }\n\n  const buildApiUrl = (rawPath, base) => {\n    if (rawPath.startsWith(\"http\")) return rawPath;\n\n    const normalizedBase = normalizeBase(base);\n    let normalizedPath = rawPath.startsWith(\"/\") ? rawPath : `/${rawPath}`;\n\n    // Prevent \"/api/api/...\" when both base and path already include \"/api\".\n    const baseEndsWithApi = normalizedBase.endsWith(\"/api\");\n    if (baseEndsWithApi && normalizedPath.startsWith(\"/api/\")) {\n      normalizedPath = normalizedPath.slice(4);\n    }\n\n    return `${normalizedBase}${normalizedPath}`;\n  };\n\n  const toError = (error) => {\n    if (error instanceof Error) return error;\n    return new Error(String(error || \"Failed to fetch\"));\n  };\n\n  const candidates = path.startsWith(\"http\")\n    ? [\"\"]\n    : API_BASES;\n  const seenCandidateKeys = new Set();\n  const uniqueCandidates = candidates.filter((item) => {\n    const key = getCandidateKey(item);\n    if (seenCandidateKeys.has(key)) return false;\n    seenCandidateKeys.add(key);\n    return true;\n  });\n  const activeCandidates = shouldFallbackBetweenBases\n    ? uniqueCandidates\n    : uniqueCandidates.slice(0, 1);\n\n  let lastError = null;\n  for (let index = 0; index < activeCandidates.length; index += 1) {\n    const base = activeCandidates[index];\n    const url = buildApiUrl(path, base);\n    let timedOut = false;\n    const controller = !fetchOptions.signal && shouldTimeout ? new AbortController() : null;\n    const timerId = controller\n      ? setTimeout(() => {\n        timedOut = true;\n        controller.abort();\n      }, Math.max(5000, timeoutValue))\n      : null;\n\n    try {\n      const response = await fetch(url, {\n        ...fetchOptions,\n        headers,\n        cache: fetchOptions.cache || \"no-store\",\n        signal: fetchOptions.signal || controller?.signal\n      });\n      return response;\n    } catch (error) {\n      if (timedOut) {\n        const timeoutError = new Error(`Request timeout after ${Math.max(5000, timeoutValue)}ms (${method} ${path})`);\n        timeoutError.name = \"AbortError\";\n        timeoutError.code = \"REQUEST_TIMEOUT\";\n        timeoutError.method = method;\n        timeoutError.path = path;\n        timeoutError.url = url;\n        timeoutError.timeoutMs = Math.max(5000, timeoutValue);\n        timeoutError.originalError = error;\n        timeoutError.requestId = requestId;\n        lastError = timeoutError;\n      } else {\n        const networkError = toError(error);\n        // Keep the error message concise but actionable in the UI.\n        if (!networkError.message || networkError.message.toLowerCase() === \"failed to fetch\") {\n          networkError.message = `${networkError.message || \"Failed to fetch\"} (${method} ${path})`;\n        }\n        networkError.code = networkError.code || \"FETCH_FAILED\";\n        networkError.method = method;\n        networkError.path = path;\n        networkError.url = url;\n        networkError.requestId = requestId;\n        networkError.originalError = error;\n        lastError = networkError;\n      }\n      const hasAnotherBase = shouldFallbackBetweenBases && index < activeCandidates.length - 1;\n      if (!hasAnotherBase) break;\n      if (!isRetryableNetworkError(lastError)) break;\n    } finally {\n      if (timerId) clearTimeout(timerId);\n    }\n  }\n\n  if (!_retried && allowRetry && isRetryableNetworkError(lastError)) {\n    await sleep(350);\n    return apiFetch(path, { ...options, _retried: true });\n  }\n  if (lastError) throw lastError;\n  const genericError = new Error(\"Failed to fetch\");\n  genericError.requestId = requestId;\n  throw genericError;\n};\n\nexport const apiFetchJson = async (path, options = {}) => {\n  const response = await apiFetch(path, options);\n  const contentType = response.headers.get(\"content-type\") || \"\";\n  let data = {};\n  let text = \"\";\n\n  if (contentType.includes(\"application/json\")) {\n    data = await response.json().catch(() => ({}));\n  } else {\n    text = await response.text().catch(() => \"\");\n  }\n\n  if (!response.ok) {\n    const textMessage = text\n      ? text.replace(/<[^>]*>/g, \" \").replace(/\\s+/g, \" \").trim().slice(0, 240)\n      : \"\";\n    const error = new Error(data?.error || data?.message || textMessage || `HTTP ${response.status}`);\n    error.status = response.status;\n    error.data = data;\n    if (text) {\n      error.raw = text;\n    }\n    throw error;\n  }\n  return contentType.includes(\"application/json\") ? data : {};\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}